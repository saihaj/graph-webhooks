/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type IntOrString = string | number;

export interface Values {
  /**
   * Usually used when using Opentelemetry-collector as a subchart.
   */
  enabled?: boolean;
  global?: {};
  /**
   * Override name of the chart used in Kubernetes object names.
   */
  nameOverride?: string;
  /**
   * Override fully qualified app name.
   */
  fullnameOverride?: string;
  mode: "daemonset" | "deployment" | "statefulset" | "";
  /**
   * Name of the namespace to deploy the resources into.
   */
  namespaceOverride?: string;
  presets?: {
    logsCollection?: {
      /**
       * Specifies whether the collector should collect logs.
       */
      enabled?: boolean;
      /**
       * Specifies whether the collector should collect its own logs.
       */
      includeCollectorLogs?: boolean;
      /**
       * Specifies whether logs checkpoints should be stored in /var/lib/otelcol/ host directory.
       */
      storeCheckpoints?: boolean;
      /**
       * Specifies the max recombine log size.
       */
      maxRecombineLogSize?: number;
    };
    hostMetrics?: {
      /**
       * Specifies whether the collector should collect host metrics.
       */
      enabled?: boolean;
    };
    kubeletMetrics?: {
      /**
       * Specifies whether the collector should collect kubelet metrics.
       */
      enabled?: boolean;
    };
    kubernetesAttributes?: {
      /**
       * Specifies whether the collector should add Kubernetes metdata to resource attributes.
       */
      enabled?: boolean;
      /**
       * Specifies whether the k8sattributes processor should extract all pod labels.
       */
      extractAllPodLabels?: boolean;
      /**
       * Specifies whether the k8sattributes processor should extract all pod annotations.
       */
      extractAllPodAnnotations?: boolean;
    };
    kubernetesEvents?: {
      /**
       * Specifies whether the collector should collect Kubernetes objects.
       */
      enabled?: boolean;
    };
    clusterMetrics?: {
      /**
       * Specifies whether the collector should collect cluster metrics.
       */
      enabled?: boolean;
    };
  };
  configMap?: {
    /**
     * Specifies whether a configMap should be created (true by default).
     */
    create?: boolean;
    /**
     * Specifies an existing configMap to be mounted to the pod
     */
    existingName?: string;
  };
  /**
   * Configuration that applies to both standalone and agent collector. Overwritable by standalone and agent specific configs.
   */
  config?: {};
  /**
   * Image use in both standalone and agent configs
   */
  image?: {
    registry?: string;
    repository?: string;
    tag?: string;
    digest?: string;
    pullPolicy?: "IfNotPresent" | "Always" | "Never";
  };
  imagePullSecrets?: {}[];
  /**
   * OpenTelemetry Collector executable
   */
  command?: {
    name?: string;
    extraArgs?: string[];
  };
  serviceAccount?: {
    create: boolean;
    annotations?: {};
    name?: string;
  };
  clusterRole?: {
    create: boolean;
    annotations?: {};
    name?: string;
    rules?: {}[];
    clusterRoleBinding?: {
      annotations?: {};
      name?: string;
    };
  };
  podSecurityContext?: {};
  securityContext?: {};
  nodeSelector?: {};
  tolerations?: {}[];
  affinity?: {};
  topologySpreadConstraints?: {}[];
  priorityClassName?: string;
  extraContainers?: {
    name: string;
    [k: string]: unknown;
  }[];
  initContainers?: {
    name: string;
    [k: string]: unknown;
  }[];
  extraEnvs?: {}[];
  extraEnvsFrom?: {}[];
  extraVolumes?: {}[];
  extraVolumeMounts?: {}[];
  ports?: {
    /**
     * This interface was referenced by `undefined`'s JSON-Schema definition
     * via the `patternProperty` ".*".
     */
    [k: string]: {
      enabled: boolean;
      containerPort?: number;
      servicePort?: number;
      hostPort?: number;
      nodePort?: number;
      protocol?: string;
      appProtocol?: string;
    };
  };
  resources?: {
    limits?: {
      cpu?: string | number;
      "ephemeral-storage"?: string;
      memory?: string;
    };
    requests?: {
      cpu?: string | number;
      "ephemeral-storage"?: string;
      memory?: string;
    };
  };
  lifecycleHooks?: {
    postStart?: {
      [k: string]: unknown;
    };
    preStop?: {
      [k: string]: unknown;
    };
  };
  livenessProbe?: {
    initialDelaySeconds?: number;
    periodSeconds?: number;
    timeoutSeconds?: number;
    failureThreshold?: number;
    terminationGracePeriodSeconds?: number;
    httpGet?: {
      port?: number;
      path?: string;
    };
  };
  readinessProbe?: {
    initialDelaySeconds?: number;
    periodSeconds?: number;
    timeoutSeconds?: number;
    successThreshold?: number;
    failureThreshold?: number;
    httpGet?: {
      port?: number;
      path?: string;
    };
  };
  podAnnotations?: {};
  podLabels?: {};
  additionalLabels?: {};
  hostNetwork?: boolean;
  hostAliases?: {}[];
  dnsPolicy?:
    | "ClusterFirst"
    | "ClusterFirstWithHostNet"
    | "Default"
    | "None"
    | "";
  dnsConfig?: {};
  replicaCount?: number;
  revisionHistoryLimit?: number;
  annotations?: {};
  service?: {
    enabled?: boolean;
    type?: "ClusterIP" | "NodePort" | "LoadBalancer" | "ExternalName";
    clusterIP?: string;
    loadBalancerIP?: string;
    loadBalancerSourceRanges?: string[];
    annotations?: {};
    internalTrafficPolicy?: "Cluster" | "Local" | "";
    externalTrafficPolicy?: "Cluster" | "Local" | "";
  };
  ingress?: {
    enabled: boolean;
    ingressClassName?: string;
    annotations?: {};
    hosts?: {
      host?: string;
      paths: {
        path: string;
        pathType: "Exact" | "Prefix" | "ImplementationSpecific";
        port: number;
      }[];
    }[];
    tls?: {
      secretName?: string;
      hosts?: string[];
    }[];
    additionalIngresses?: {
      name: string;
      ingressClassName?: string;
      annotations?: {};
      hosts?: {
        host?: string;
        paths: {
          path: string;
          pathType: "Exact" | "Prefix" | "ImplementationSpecific";
          port: number;
        }[];
      }[];
      tls?: {
        secretName?: string;
        hosts?: string[];
      }[];
    }[];
  };
  podMonitor?: {
    enabled: boolean;
    metricsEndpoints?: {}[];
    extraLabels?: {};
  };
  serviceMonitor?: {
    enabled: boolean;
    metricsEndpoints?: {}[];
    extraLabels?: {};
  };
  podDisruptionBudget?: {
    enabled: boolean;
  };
  autoscaling?: {
    enabled: boolean;
    minReplicas?: number;
    maxReplicas?: number;
    behavior?: {};
    targetCPUUtilizationPercentage?: number;
  };
  rollout?: {
    rollingUpdate?: {
      maxSurge?: IntOrString;
      maxUnavailable?: IntOrString;
    };
    strategy: "OnDelete" | "Recreate" | "RollingUpdate";
  };
  prometheusRule?: {
    enabled: boolean;
    groups?: {}[];
    defaultRules?: {
      enabled: boolean;
    };
    extraLabels?: {};
  };
  statefulset?: {
    volumeClaimTemplates?: {}[];
    podManagementPolicy?: string;
  };
  networkPolicy?: {
    enabled?: boolean;
    annotations?: {};
    /**
     * List of sources which should be able to access the collector. See the standard NetworkPolicy 'spec.ingress.from' definition for more information: https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/. If left empty, ingress traffic will be permitted on to all enabled ports from all sources.
     */
    allowIngressFrom?: {}[];
    /**
     * Additional ingress rules to apply to the policy. See the standard NetworkPolicy 'spec.ingress' definition for more information: https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/
     */
    extraIngressRules?: {}[];
    /**
     * Optional egress configuration, see the standard NetworkPolicy 'spec.egress' definition for more information: https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/network-policy-v1/
     */
    egressRules?: {}[];
  };
  useGOMEMLIMIT?: boolean;
  shareProcessNamespace?: boolean;
}
